import os
import datetime
import json
import re
from typing import Dict, Any, List, Optional, Tuple

from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from google.auth.transport.requests import Request
import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()

# --- Constants ---
GOOGLE_API_KEY_ENV_VAR = "GOOGLE_API_KEY"
GOOGLE_CALENDAR_SCOPES = [
    'https://www.googleapis.com/auth/calendar.events',
    'https://www.googleapis.com/auth/calendar'] # Added .events
CALENDAR_API_VERSION = 'v3'
CALENDAR_ID_PRIMARY = 'primary'
DEFAULT_TIMEZONE = os.environ.get("DEFAULT_TIMEZONE", 'Asia/Dhaka') # Using your default timezone
GEMINI_MODEL_NAME = 'gemini-1.5-flash'

class LearningPlannerService:
    def __init__(self):
        api_key = os.environ.get(GOOGLE_API_KEY_ENV_VAR)
        if not api_key:
            raise ValueError(f"{GOOGLE_API_KEY_ENV_VAR} not found. Service cannot start.")
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel(GEMINI_MODEL_NAME)
        
        self.creds = self._get_oauth_credentials()
        self.calendar_service = build('calendar', CALENDAR_API_VERSION, credentials=self.creds)

        # In-memory storage for the last integrated plan and its links
        # These will be wiped on server restart. For persistence, use a database.
        self.last_generated_plan_tasks: Optional[List[Dict[str, Any]]] = None # Stores the tasks generated by AI
        self.last_generated_plan_skill_name: Optional[str] = None # Stores the goal/skill name for the generated plan
        self.last_integrated_calendar_links: Optional[List[str]] = None # Stores the actual event links after integration

    def _get_oauth_credentials(self) -> Credentials:
        creds = None
        token_file = 'token.json'
        creds_file = 'credentials.json'

        if not os.path.exists(creds_file):
            raise FileNotFoundError(
                f"{creds_file} not found. OAuth cannot proceed. "
                "Ensure it's present and an initial token.json might need to be generated manually for the server environment."
            )

        if os.path.exists(token_file):
            creds = Credentials.from_authorized_user_file(token_file, GOOGLE_CALENDAR_SCOPES)
        
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                try:
                    print("Refreshing OAuth token for service...")
                    creds.refresh(Request())
                except Exception as e:
                    print(f"Error refreshing token: {e}. Deleting old token if exists.")
                    if os.path.exists(token_file): os.remove(token_file)
                    raise ConnectionRefusedError(
                        "OAuth token refresh failed and interactive flow is not suitable for server. "
                        "Manual token refresh or alternative auth method needed."
                    ) from e
            else:
                print(f"Warning: No valid {token_file}. For a server, an initial token should be present. "
                      "Attempting interactive flow (may fail or block in non-interactive env)...")
                try:
                    flow = InstalledAppFlow.from_client_secrets_file(creds_file, GOOGLE_CALENDAR_SCOPES)
                    creds = flow.run_local_server(port=0)
                except Exception as e:
                    raise ConnectionRefusedError(
                        "OAuth interactive flow failed. A pre-authorized token.json is likely needed for this environment."
                    ) from e

            with open(token_file, 'w') as token:
                token.write(creds.to_json())
            print("OAuth token obtained/refreshed and saved for service.")
        return creds

    # Removed _extract_valid_json_from_response as we will use specific delimiters
    # and a more targeted regex.

    def _parse_preferred_time_to_datetime_time(self, preferred_time_str: Optional[str]) -> datetime.time:
        hours, minutes = 9, 0 # Default
        if not preferred_time_str: return datetime.time(hours, minutes)
        try:
            time_match = re.search(r'(\d{1,2})(?:[:.](\d{1,2}))?\s*(am|pm)?', preferred_time_str, re.IGNORECASE)
            if time_match:
                hr_part = int(time_match.group(1))
                min_part_str = time_match.group(2)
                minutes = int(min_part_str) if min_part_str else 0
                ampm_part = (time_match.group(3) or '').lower()
                if ampm_part == 'pm' and 1 <= hr_part < 12: hours = hr_part + 12
                elif ampm_part == 'am' and hr_part == 12: hours = 0
                else: hours = hr_part
                if not (0 <= hours <= 23 and 0 <= minutes <= 59): hours, minutes = 9,0
            elif "morning" in preferred_time_str.lower(): hours = 9
            elif "afternoon" in preferred_time_str.lower(): hours = 14
            elif "evening" in preferred_time_str.lower() or "night" in preferred_time_str.lower(): hours = 19
        except Exception: pass # Default to 09:00
        return datetime.time(hours, minutes)

    def handle_chat_message(self, user_message: str, chat_history: List[Dict[str, Any]]) -> str:
        # Note: In the previous main_api.py, the chatHistory was passed as a list of dicts.
        # This conversion here ensures compatibility if the `contents` parameter of generate_content
        # expects genai.protos.Content objects directly.

        # Ensure 'role' in chat_history matches Gemini's expectations ('user', 'model')
        # Your frontend might send 'ai' for AI messages, convert it to 'model'.
        formatted_history = []
        for msg in chat_history:
            role = 'model' if msg.get('role') == 'model' else 'user' # Ensure 'model' for AI, 'user' otherwise
            text_parts = [part['text'] for part in msg.get('parts', []) if 'text' in part]
            if text_parts:
                formatted_history.append({'role': role, 'parts': [{'text': '\n'.join(text_parts)}]})

        try:
            chat = self.model.start_chat(history=formatted_history)
            response = chat.send_message(user_message)
            return response.text.strip()
        except Exception as e:
            print(f"Error in handle_chat_message: {e}")
            return f"Sorry, I encountered an error trying to process your message: {str(e)}"

    def generate_structured_plan(self,
                                 goal: str,
                                 duration_days: int,
                                 start_date_str: str, # Expected YYYY-MM-DD
                                 learning_style: Optional[str],
                                 preferred_time_str: Optional[str], # e.g., "9 AM", "evening"
                                 daily_hours: Optional[float],
                                 chat_history_for_context: Optional[List[Dict[str, Any]]] = None, # Full chat history for AI context
                                 refinement_instruction: Optional[str] = None,
                                 existing_plan_tasks_for_refinement: Optional[List[Dict[str, Any]]] = None
                                 ) -> Tuple[Optional[List[Dict[str, Any]]], str]: # (structured_tasks, human_readable_or_error)

        # Using your existing date handling for start_date
        current_date_obj = datetime.date.today() # Get current date for context

        # Build the prompt for Gemini
        prompt_parts = []
        # Introduce the main instructions for the AI, focusing on the output format
        prompt_parts.append("As an AI specialized in generating structured learning plans, provide two distinct outputs:")
        prompt_parts.append("1. A 'human_readable_plan' which is a conversational, detailed, multi-paragraph summary of the learning plan.")
        prompt_parts.append("2. A 'structured_tasks' component as a JSON array of objects. EACH object must represent a single task.")
        prompt_parts.append("Strictly adhere to the following JSON structure for each task object:")
        prompt_parts.append("   - `summary` (string): A concise title for the task (e.g., 'Learn FastAPI Basics', 'Build User Authentication').")
        prompt_parts.append("   - `description` (string, nullable): A more detailed explanation of what the task involves. Can be null if not applicable.")
        prompt_parts.append("   - `startTime` (string): ISO 8601 formatted datetime (YYYY-MM-DDTHH:MM:SS) for when the task starts. Ensure it includes time and is in the local timezone of '"+DEFAULT_TIMEZONE+"'.")
        prompt_parts.append("   - `endTime` (string): ISO 8601 formatted datetime (YYYY-MM-DDTHH:MM:SS) for when the task ends. Must be after startTime and in the local timezone of '"+DEFAULT_TIMEZONE+"'.")
        prompt_parts.append("\nPlace the JSON block **ONLY** after the human_readable_plan.")
        prompt_parts.append("Use the precise delimiters `---JSON_PLAN_START---` and `---JSON_PLAN_END---` to clearly mark the JSON block.")
        prompt_parts.append("Ensure the JSON is valid and can be directly parsed without issues.")
        prompt_parts.append(f"The current date is {current_date_obj.strftime('%Y-%m-%d')}. Adjust suggested start dates if they fall in the past to a sensible future date (e.g., next Monday).")


        # Add the specific plan generation or refinement request
        if refinement_instruction and existing_plan_tasks_for_refinement:
            prompt_parts.append(f"\n\n***PLAN REFINEMENT REQUEST***")
            prompt_parts.append(f"Refine the following existing plan for the goal '{goal}':")
            # Present existing tasks in a readable format for the AI
            for i, task in enumerate(existing_plan_tasks_for_refinement):
                prompt_parts.append(f"- Task {i+1}: '{task.get('summary', 'N/A')}' from {task.get('startTime', 'N/A')} to {task.get('endTime', 'N/A')}. Desc: {task.get('description', 'N/A')}")
            prompt_parts.append(f"\nRefinement instruction: '{refinement_instruction}'")
            prompt_parts.append(f"The plan should still be for {duration_days} days, starting around {start_date_str}.")
            if daily_hours is not None: prompt_parts.append(f"Maintain daily study hours around {daily_hours} hours.")
            if preferred_time_str: prompt_parts.append(f"Consider the preferred time of day: {preferred_time_str}.")

        else:
            prompt_parts.append(f"\n\n***NEW PLAN GENERATION REQUEST***")
            prompt_parts.append(f"Generate a detailed learning plan with the following details:")
            prompt_parts.append(f"- Goal/Skill: {goal}")
            prompt_parts.append(f"- Duration: {duration_days} days")
            prompt_parts.append(f"- Desired Start Date: {start_date_str}")
            if learning_style: prompt_parts.append(f"- Learning Style: {learning_style}")
            if preferred_time_str: prompt_parts.append(f"- Preferred Study Time: {preferred_time_str}")
            if daily_hours is not None: prompt_parts.append(f"- Daily Study Hours: {daily_hours}")

        full_prompt = "\n".join(prompt_parts)

        # Prepare chat history for `generate_content`
        # `generate_content` expects a list of `genai.types.Content` objects or compatible dicts
        gemini_contents_for_api_call = []
        if chat_history_for_context:
            for msg in chat_history_for_context:
                role = 'model' if msg.get('role') == 'model' else 'user'
                text_parts = [part['text'] for part in msg.get('parts', []) if 'text' in part]
                if text_parts:
                    gemini_contents_for_api_call.append({'role': role, 'parts': [{'text': '\n'.join(text_parts)}]})
        
        # Add the current planning prompt as the last user turn
        gemini_contents_for_api_call.append({'role': 'user', 'parts': [{'text': full_prompt}]})

        try:
            generation_config = {
                "temperature": 0.7, # Adjusted for more creative but still coherent plans
                "top_p": 0.95,
                "top_k": 64,
                "max_output_tokens": 8192,
            }
            response = self.model.generate_content(
                contents=gemini_contents_for_api_call,
                generation_config=generation_config
            )
            ai_response_text = response.text.strip()

            # ---  DEBUG PRINTS ---
            print("\n--- DEBUG: Raw AI Response from Gemini ---")
            print(ai_response_text)
            print("--- END DEBUG: Raw AI Response ---\n")
            # --- END DEBUG PRINTS ---
            
            # Check for safety feedback if content was blocked
            if response.prompt_feedback and response.prompt_feedback.block_reason:
                reason = response.prompt_feedback.block_reason
                msg = response.prompt_feedback.block_reason_message
                print(f"Plan generation blocked by API: {reason} - {msg}")
                return None, f"Plan generation failed due to content policy: {reason}. Please rephrase. ({msg})"

        except Exception as e:
            print(f"Error calling Gemini for plan generation: {e}")
            return None, f"Error communicating with AI: {str(e)}"

        # --- Extract and Parse Structured Tasks ---
        json_start_tag = "---JSON_PLAN_START---"
        json_end_tag = "---JSON_PLAN_END---"
        
        human_readable_plan_content = ai_response_text
        structured_api_tasks: List[Dict[str, Any]] = []

        if json_start_tag in ai_response_text and json_end_tag in ai_response_text:
                        # 1. Get the content between the main delimiters (---JSON_PLAN_START--- and ---JSON_PLAN_END---)
            parts = ai_response_text.split(json_start_tag, 1)
            if len(parts) < 2: 
                print("DEBUG: Start delimiter not found correctly.")
                return None, "AI did not provide a structured plan in the expected format (start delimiter missing)."
            
            content_after_start = parts[1]
            
            sub_parts = content_after_start.split(json_end_tag, 1)
            if len(sub_parts) < 2: 
                print("DEBUG: End delimiter not found correctly.")
                return None, "AI did not provide a structured plan in the expected format (end delimiter missing)."
            
            # This is the raw block including ```json and the closing ```
            json_block_with_markdown = sub_parts[0].strip() 

            # Set the human-readable part (everything before the start tag)
            human_readable_plan_content = ai_response_text.split(json_start_tag, 1)[0].strip()

            # 2. Remove the inner markdown code block delimiters (```json and ```)
            json_content_only = json_block_with_markdown
            if json_content_only.startswith("```json"):
                json_content_only = json_content_only[len("```json"):].strip()
            if json_content_only.endswith("```"):
                json_content_only = json_content_only[:-len("```")].strip()

            # 3. Aggressively clean up any lingering invisible characters or extra whitespace
            # Replace common problematic unicode whitespace (like non-breaking space) with regular space
            json_content_only = json_content_only.replace('\u00A0', ' ') 
            # Normalize all whitespace (collapse multiple spaces, remove leading/trailing)
            json_block = ' '.join(json_content_only.split()).strip() 
            
            # --- DEBUG PRINT FOR THE CLEANED JSON ---
            print("\n--- DEBUG: Cleaned JSON Block before json.loads ---")
            print(repr(json_block)) # Use repr() to see hidden characters
            print("--- END DEBUG: Cleaned JSON Block ---\n")
            # --- END DEBUG PRINT ---
            
            try:
                # Attempt to load the JSON block
                parsed_structured_data = json.loads(json_block)
                
                # The AI's JSON structure for 'learningPlan' is different from the 'BackendTask'
                # We need to convert it to the 'BackendTask' format (summary, description, startTime, endTime)
                if isinstance(parsed_structured_data, dict) and "learningPlan" in parsed_structured_data:
                    ai_learning_plan = parsed_structured_data["learningPlan"]
                    
                    # Master start date and preferred time from AI's top-level or input defaults
                    ai_start_date_str = parsed_structured_data.get("start_date", start_date_str)
                    ai_daily_hours = float(parsed_structured_data.get("daily_hours", daily_hours if daily_hours is not None else 2.0))
                    ai_preferred_time_str = parsed_structured_data.get("preferred_time", preferred_time_str)
                    
                    # Correct overall start date if in past, same logic as your original `_parse_preferred_time_to_datetime_time`
                    corrected_master_start_date: datetime.date
                    try:
                        temp_parsed_date = datetime.datetime.strptime(ai_start_date_str, '%Y-%m-%d').date()
                        if temp_parsed_date < current_date_obj:
                            corrected_master_start_date = current_date_obj + datetime.timedelta(days=1) # Start tomorrow
                        else:
                            corrected_master_start_date = temp_parsed_date
                    except ValueError:
                        corrected_master_start_date = current_date_obj + datetime.timedelta(days=1) # Default to tomorrow
                        print(f"AI provided invalid overall start_date '{ai_start_date_str}'. Defaulting plan start to tomorrow.")

                    preferred_dt_time_obj = self._parse_preferred_time_to_datetime_time(ai_preferred_time_str)

                    for i, day_entry in enumerate(ai_learning_plan):
                        task_date = corrected_master_start_date + datetime.timedelta(days=i)
                        
                        objective = day_entry.get("objective", "Learning Task")
                        projects = day_entry.get("projects_exercises", "")
                        estimated_hours = float(day_entry.get("estimated_time_hours", ai_daily_hours))

                        task_start_dt = datetime.datetime.combine(task_date, preferred_dt_time_obj)
                        task_end_dt = task_start_dt + datetime.timedelta(hours=estimated_hours)

                        structured_api_tasks.append({
                            "summary": f"Day {day_entry.get('dayNumber', i+1)}: {objective}",
                            "description": projects,
                            "startTime": task_start_dt.isoformat(),
                            "endTime": task_end_dt.isoformat()
                        })
                elif isinstance(parsed_structured_data, list):
                     # If AI directly outputted the list of tasks in BackendTask format
                     # This is less likely with the prompt but good to have as fallback
                    structured_api_tasks = parsed_structured_data
                else:
                    return None, "AI generated JSON, but 'learningPlan' array or expected structure was not found within it."
            except json.JSONDecodeError as e:
                print(f"JSON parsing error after delimiters: {e}. Raw JSON block:\n{json_block}")
                return None, f"AI generated an invalid structured plan: {e}. Raw: {json_block[:200]}"
            except Exception as e:
                print(f"Error processing AI structured data: {e}")
                return None, f"An unexpected error occurred while parsing the AI's plan: {e}"
        else:
            print("DEBUG: Delimiters not found in AI response. Returning error message.") # Added debug here
            return None, "AI did not provide a structured plan in the expected format (missing `---JSON_PLAN_START---` and `---JSON_PLAN_END---` delimiters)."

        if not structured_api_tasks:
            return None, "AI generated an empty or malformed structured task list."

        # Store the generated plan for potential display in calendar view
        self.last_generated_plan_tasks = structured_api_tasks
        self.last_generated_plan_skill_name = goal

        return structured_api_tasks, human_readable_plan_content

    def add_plan_to_calendar(self, skill_name: str, structured_tasks: List[Dict[str, Any]]) -> Tuple[str, Optional[List[str]]]:
        if not self.calendar_service:
            return "Calendar service not available. Please check server authentication.", None
        
        # Refresh creds just in case before a batch of writes
        try:
            if not self.creds.valid:
                self.creds.refresh(Request())
        except Exception as e:
            print(f"Could not refresh calendar token before adding events: {e}. Proceeding with existing token.")
            # Proceed with existing creds, might fail if actually expired and unrefreshable
        
        created_event_links = []
        events_created_count = 0
        for task_data in structured_tasks:
            try:
                summary = task_data.get("summary", f"{skill_name} Task")
                description = task_data.get('description', '')
                start_time_iso = task_data.get("startTime")
                end_time_iso = task_data.get("endTime")

                if not (start_time_iso and end_time_iso):
                    print(f"Skipping task '{summary}' due to missing start/end time.")
                    continue

                event_body = {
                    'summary': summary,
                    'description': description,
                    'start': {'dateTime': start_time_iso, 'timeZone': DEFAULT_TIMEZONE},
                    'end': {'dateTime': end_time_iso, 'timeZone': DEFAULT_TIMEZONE},
                }
                created_event = self.calendar_service.events().insert(calendarId=CALENDAR_ID_PRIMARY, body=event_body).execute()
                created_event_links.append(created_event.get('htmlLink'))
                events_created_count +=1
            except Exception as e:
                print(f"Error creating calendar event for task '{summary}': {e}")
        
        # Store the integrated plan's links (and the tasks again for consistency if needed by get_last_integrated_plan_for_display)
        # Note: self.last_generated_plan_tasks might hold the *original* generated tasks,
        # here we are confirming the tasks that were *successfully integrated*.
        # For simplicity, let's keep it updated with the generated one unless refined later
        # However, for `get_last_integrated_plan_for_display`, it should return the *generated* plan for the plan dialog,
        # and calendar links separately.
        # So, we only update `self.last_integrated_calendar_links` here.
        self.last_integrated_calendar_links = created_event_links

        if events_created_count > 0:
            return f"Successfully added {events_created_count} tasks to Google Calendar.", created_event_links
        else:
            return "No events were added to Google Calendar. Check logs for details.", None

    # --- New Getter Methods for main_api.py and frontend ---
    def get_last_integrated_plan_for_display(self) -> Tuple[Optional[List[Dict[str, Any]]], Optional[str]]:
        """
        Retrieves the last GENERATED plan's structured tasks and skill name for display in the plan dialog.
        """
        return self.last_generated_plan_tasks, self.last_generated_plan_skill_name

    def get_last_integrated_plan_calendar_links(self) -> Optional[List[str]]:
        """
        Retrieves the calendar event links for the last INTEGRATED plan.
        """
        return self.last_integrated_calendar_links